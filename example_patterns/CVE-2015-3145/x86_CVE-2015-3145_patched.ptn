; This pattern tests for the patch of CVE-2015-3145 for x86:LE:64:default.

; Info about the CVE: https://github.com/curl/curl/commit/b5f947b8ac0e282c61c75b69cd5b9d37dafc6959
; Summary: A cookie path is passed into a function, and the first character is removed if it is a
; double quote. It then checks if the last character (strlen(new_path) - 1) is a double quote and
; sets the last character to 0 if so. If a single double quote is passed in as the cookie path, the
; last character's index would be calculated as -1.

; Patched code:
; len = strlen(new_path);
; if(new_path[0] == '\"') {
;   memmove((void *)new_path, (const void *)(new_path + 1), len);
;   len--;
; }
; if(len && (new_path[len - 1] == '\"')) {
;   new_path[len - 1] = 0x0;
;   len--;
; }

; Pattern written with: libcurl/libcurl_versions/from_tool/testdata/libcurl.so.4.4.0_OceanStor BCManager V200R001C00SPC220__1.action.16f41eb05d826e68ec793247c65ede64ce2ff854e2409379e438e8fe3b18bb24
;        0010ed9e e8 fd 9e        CALL       <EXTERNAL>::strlen
;                 ff ff
;        0010eda3 80 3b 22        CMP        byte ptr [RBX],0x22
;        0010eda6 48 89 c5        MOV        RBP,RAX
;        0010eda9 74 4d           JZ         LAB_0010edf8
;        0010edab 48 85 ed        TEST       RBP,RBP
;        0010edae 74 60           JZ         LAB_0010ee10
;                             LAB_0010edb0
;        0010edb0 48 8d 55 ff     LEA        RDX,[RBP + -0x1]
;        0010edb4 48 8d 04 13     LEA        RAX,[RBX + RDX*0x1]
;        0010edb8 80 38 22        CMP        byte ptr [RAX],0x22
;        0010edbb 74 23           JZ         LAB_0010ede0
; ...
;                              LAB_0010ede0
;        0010ede0 c6 00 00        MOV        byte ptr [RAX],0x0
; ...
;                              LAB_0010edf8
;        0010edf8 48 8d 73 01     LEA        RSI,[RBX + 0x1]
;        0010edfc 48 89 c2        MOV        RDX,RAX
;        0010edff 48 89 df        MOV        RDI,RBX
;        0010ee02 48 83 ed 01     SUB        RBP,0x1
;        0010ee06 e8 35 a3        CALL       <EXTERNAL>::memmove
;                 ff ff


; call to strlen
CALL `*`

; new_path[0] == '\"'
CMP byte ptr [`Q1/R..`],0x22
`ANY_BYTES{0,4}`
JZ `*`

`ANY_BYTES{0,8}`

; the second len--
LEA `Q2/R..`,[`Q3/R..` + -0x1]

`ANY_BYTES{0,8}`

; new_path[strlen(new_path) - 1] == '\"'
`START_OR`
    CMP byte ptr [`Q4/R..`],0x22
`OR`
    CMP `Q6/..`,0x22
`END_OR`
JZ `*`

`ANY_BYTES{30,78}`

; put 0 in new_path[strlen(new_path) - 1] if above true
MOV byte ptr [`Q4`],0x0

`ANY_BYTES{20,36}`

; call memmove and first len--
LEA RSI,[`Q1` + 0x1]
MOV RDX,`Q5/R..`
MOV RDI,`Q1`
SUB `Q3`,0x1
CALL `*`

; Copyright (C) 2025 The MITRE Corporation All Rights Reserved
